import * as React from 'react';import { useIntl } from 'react-intl';import * as dayjs from 'dayjs';import { v4 as uuid } from 'uuid';import RangeFormContainer from '../../../Shared/TimeWindow/RangeFormContainer/RangeFormContainer';import { SelectionCount, SelectionHint, AddButton } from '../../../Shared';import Grid from '../../../Shared/TimeWindow/Grid/Grid';import Day from '../../../Shared/TimeWindow/Day/Day';import * as S from '../../../RangeFilter.styles';import { WeeklyProps, WeeklySchedule, WeeklyScheduleDayValue } from './Weekly.types';import { DateLimitMode } from '../../../Shared/TimeWindow/RangeFormContainer/RangeForm/RangeForm.types';import { DayKey } from '../../WeeklyFilter/WeeklyFilter.types';import { TimeWindowTexts } from '../../../Shared/TimeWindow/TimeWindow.types';import { useShiftAndControlKeys } from '../hooks/useShiftAndControlKeys';import { canAddAnotherRange, haveActiveDaysCommonRange, range } from './utils';import {  DEFAULT_RANGE_START,  DEFAULT_RANGE_END,  DEFAULT_TIME_FORMAT,  EMPTY_OBJECT,  MAX_RANGES,  RENDER_EMPTY_NODE_FN,  NOOP,} from '../constants';const Weekly: React.FC<WeeklyProps> = ({  valueSelectionMode = ['Hour', 'Range'],  timeFormat = 'HH:mm',  value,  timePickerProps,}) => {  const defaultDayValue = React.useMemo(    () => ({      start: DEFAULT_RANGE_START,      stop: DEFAULT_RANGE_END,      restricted: false,      display: false,      inverted: false,      mode: valueSelectionMode[0],    }),    [valueSelectionMode]  );  const [schedule, setSchedule] = React.useState<WeeklySchedule>(value || {});  const [filteredSchedule, setFilteredSchedule] = React.useState<string[]>(Object.keys(schedule));  const [activeDays, setActiveDays] = React.useState<DayKey[]>([]);  const ref = React.useRef<HTMLDivElement>();  const [controlKeyPressed, shiftKeyPressed] = useShiftAndControlKeys(ref);  const intl = useIntl();  const allKeys = React.useMemo(() => range(0, 7), []);  React.useEffect((): void => {    setSchedule(value);  }, [value]);  const removeEmptyEntries = React.useCallback((weeklySchedule: WeeklySchedule) => {    const emptyEntries = Object.keys(weeklySchedule).filter(key => Object.keys(weeklySchedule[key]).length === 0);    const scheduleToUpdate = weeklySchedule;    emptyEntries.forEach(emptyEntry => {      delete scheduleToUpdate[emptyEntry];    });    setSchedule(scheduleToUpdate);  }, []);  React.useEffect(() => {    const entriesWithActiveDaysValue = Object.keys(schedule).filter(id =>      activeDays.every(day => !!schedule[id][day] && haveActiveDaysCommonRange(schedule[id], activeDays))    );    removeEmptyEntries(schedule);    setFilteredSchedule(entriesWithActiveDaysValue);  }, [schedule, activeDays, removeEmptyEntries]);  const handleDayTimeChange = React.useCallback(    (dayValue: [Date, Date], dayKey: DayKey | DayKey[], guid: string): void => {      const updatedSchedule = schedule;      if (dayKey instanceof Array) {        dayKey.forEach(day => {          updatedSchedule[guid][day] = {            ...schedule[guid][day],            restricted: true,            start: dayjs(dayValue[0]).format(DEFAULT_TIME_FORMAT),            stop: dayjs(dayValue[1]).format(DEFAULT_TIME_FORMAT),          };        });      } else {        updatedSchedule[guid][dayKey] = {          ...schedule[guid][dayKey],          restricted: true,          start: dayjs(dayValue[0]).format(DEFAULT_TIME_FORMAT),          stop: dayjs(dayValue[1]).format(DEFAULT_TIME_FORMAT),        };      }      setSchedule(updatedSchedule);    },    [schedule]  );  const getDayValue = React.useCallback(    (dayKey: DayKey, guid: string): WeeklyScheduleDayValue => {      if (typeof dayKey === 'number' && schedule[guid] && !!schedule[guid][dayKey]) {        return schedule[guid][dayKey];      }      return defaultDayValue;    },    [schedule, defaultDayValue]  );  const handleModeChange = React.useCallback(    (selectedMode: DateLimitMode, dayKeys: DayKey[], guid: string): void => {      const updatedSchedule = schedule;      dayKeys.forEach(day => {        updatedSchedule[guid][day] = {          ...schedule[guid][day],          mode: selectedMode,        };      });      setSchedule(updatedSchedule);    },    [schedule]  );  const handleRangeDelete = React.useCallback(    (guid: string, activeDaysArray): void => {      const updatedSchedule = schedule;      activeDaysArray.forEach((activeDay: DayKey) => {        delete updatedSchedule[guid][activeDay];      });      setSchedule({ ...updatedSchedule });    },    [schedule]  );  const dayFormatter = React.useCallback(    (dayKey: DayKey): React.ReactNode => intl.formatMessage({ id: `DS.DATE-RANGE-PICKER.WEEKDAYS-SHORT-${dayKey}` }),    [intl]  );  const checkDay = React.useCallback((dayKey: DayKey): void => {    setActiveDays([dayKey]);  }, []);  const getDayLabel = React.useCallback(    (dayKey: DayKey): React.ReactNode => {      return dayFormatter(dayKey);    },    [dayFormatter]  );  const isDayRestricted = React.useCallback(    (dayKey: DayKey): boolean => {      return Object.keys(schedule).some((key: string) => !!schedule[key][dayKey]);    },    [schedule]  );  const removeDaySelection = React.useCallback(    (dayKey: DayKey) => {      const updatedSchedule = schedule;      Object.keys(schedule).forEach(key => {        delete updatedSchedule[key][dayKey];      });      setActiveDays(activeDays.filter(day => day !== dayKey));      setSchedule(updatedSchedule);    },    [schedule, activeDays]  );  const uncheckActiveDay = React.useCallback(    (dayKey: DayKey): void => {      removeDaySelection(dayKey);    },    [removeDaySelection]  );  const handleSelectAll = React.useCallback((): void => {    setActiveDays(allKeys);  }, [allKeys]);  const handleUnselectAll = React.useCallback((): void => {    setActiveDays([]);  }, []);  const checkActiveDay = React.useCallback(    (dayKey: DayKey): void => {      if (!isDayRestricted(dayKey)) {        checkDay(dayKey);      }      let updatedActiveDay: DayKey[] = [];      if (controlKeyPressed) {        updatedActiveDay = activeDays.includes(dayKey) ? activeDays : [...activeDays, dayKey];      } else if (activeDays.length > 0 && shiftKeyPressed) {        updatedActiveDay =          activeDays[0] < dayKey ? range(+activeDays[0], +dayKey + 1) : range(+dayKey, +activeDays[0] + 1);      } else {        updatedActiveDay = [dayKey];      }      setActiveDays(updatedActiveDay);    },    [checkDay, isDayRestricted, activeDays, controlKeyPressed, shiftKeyPressed]  );  const handleToggleDay = React.useCallback(    (dayKey: DayKey, forcedState?: boolean): void => {      if (typeof forcedState !== 'undefined') {        if (controlKeyPressed && forcedState) {          activeDays.includes(dayKey) ? uncheckActiveDay(dayKey) : checkActiveDay(dayKey);          return;        }        forcedState ? checkActiveDay(dayKey) : uncheckActiveDay(dayKey);      } else {        activeDays.includes(dayKey) ? uncheckActiveDay(dayKey) : checkActiveDay(dayKey);      }    },    [controlKeyPressed, activeDays, uncheckActiveDay, checkActiveDay]  );  const renderDay = React.useCallback(    (dayKey: DayKey): JSX.Element => {      const isActive = activeDays.includes(dayKey);      return (        <Day          key={dayKey}          dayKey={dayKey}          data-attr={dayKey}          label={getDayLabel(dayKey)}          restricted={isDayRestricted(dayKey)}          active={isActive}          readOnly={false}          intl={intl}          onToggle={handleToggleDay}          texts={EMPTY_OBJECT}        />      );    },    [activeDays, intl, getDayLabel, handleToggleDay, isDayRestricted]  );  const handleRangeAdd = React.useCallback((): void => {    const updated = {};    const guid = Object.keys(schedule).find(key => activeDays.every(day => schedule[key][day] === undefined));    activeDays.forEach(day => {      updated[day] = defaultDayValue;    });    const restOfScheduleObject = guid ? schedule[guid] : EMPTY_OBJECT;    setSchedule({      ...schedule,      [guid || uuid()]: {        ...restOfScheduleObject,        ...updated,      },    } as WeeklySchedule);  }, [schedule, activeDays, defaultDayValue]);  const gridTitle = React.useMemo(    () => (      <SelectionCount        selectedDayCount={activeDays.length}        label={intl.formatMessage({ id: 'DS.DATE-RANGE-PICKER.SELECTED', defaultMessage: 'Selected' })}      />    ),    [intl, activeDays]  );  const canAddRange = canAddAnotherRange(schedule, activeDays);  const isAnyDaySelected = activeDays.length > 0;  const shouldRenderAddButton = isAnyDaySelected && filteredSchedule.length < MAX_RANGES && canAddRange;  return (    <S.NewFilterContainer ref={ref as React.RefObject<HTMLDivElement>}>      <Grid        reverseGroup={0}        onUnselectAll={handleUnselectAll}        onSelectAll={handleSelectAll}        showUnselectAll={Boolean(activeDays.length)}        showSelectAll        renderDay={renderDay}        keys={allKeys}        days={EMPTY_OBJECT}        intl={intl}        numberOfDays={7}        texts={EMPTY_OBJECT}        title={gridTitle}      />      {filteredSchedule.map((guid, index) => (        <RangeFormContainer          days={EMPTY_OBJECT}          onChange={NOOP}          key={`schedule-range-${guid}`}          onDayTimeChange={(dayValue, dayKey): void => {            handleDayTimeChange(dayValue, dayKey, guid);          }}          texts={EMPTY_OBJECT as TimeWindowTexts}          onMultipleDayTimeChange={(dates: [Date, Date]): void => handleDayTimeChange(dates, activeDays, guid)}          dayKeys={activeDays}          // eslint-disable-next-line @typescript-eslint/no-explicit-any          getDayLabel={getDayLabel as any}          activeDays={activeDays}          getDayValue={(dayKey: DayKey): WeeklyScheduleDayValue => getDayValue(dayKey, guid)}          onRangeDelete={(): void => handleRangeDelete(guid, activeDays)}          onModeChange={(mode): void => handleModeChange(mode, activeDays, guid)}          valueSelectionModes={valueSelectionMode}          hideHeader={index !== 0}          renderSuffix={RENDER_EMPTY_NODE_FN}          timePickerProps={timePickerProps}          timeFormat={timeFormat}        />      ))}      {isAnyDaySelected && !canAddRange && <SelectionHint message="You cannot add another range because..." />}      {shouldRenderAddButton && <AddButton label="Add range" onClick={handleRangeAdd} />}      {!isAnyDaySelected && <SelectionHint message="Select range" />}    </S.NewFilterContainer>  );};export default Weekly;