import * as React from 'react';import RangeFormContainer from '@synerise/ds-date-range-picker/dist/RangeFilter/Shared/TimeWindow/RangeFormContainer/RangeFormContainer';import * as dayjs from 'dayjs';import {  DEFAULT_RANGE_END,  DEFAULT_RANGE_START,  TIME_FORMAT,} from '@synerise/ds-date-range-picker/dist/RangeFilter/constants';import AddButton from '@synerise/ds-date-range-picker/dist/RangeFilter/Shared/AddButton/AddButton';import { DateLimitMode } from '@synerise/ds-date-range-picker/dist/RangeFilter/Shared/TimeWindow/RangeFormContainer/RangeForm/RangeForm.types';import * as S from '../../TimeWindow.styles';import { DailyProps, WeeklySchedule } from './Weekly.types';import SelectionCount from '@synerise/ds-date-range-picker/dist/RangeFilter/Shared/SelectionCount/SelectionCount';import Grid from '@synerise/ds-date-range-picker/dist/RangeFilter/Shared/TimeWindow/Grid/Grid';import { useIntl } from 'react-intl';import { DayKey } from '@synerise/ds-date-range-picker/dist/RangeFilter/Shared/TimeWindow/TimeWindow.types';import { range } from 'lodash';import { v4 as uuid } from 'uuid';import Day from '@synerise/ds-date-range-picker/dist/RangeFilter/Shared/TimeWindow/Day/Day';import { useShiftAndControlKeys } from '../../hooks/useShiftAndControlKeys';import { canAddAnotherRange, haveActiveDaysCommonRange } from './utils';import { RefObject } from 'react';import SelectionHint from '@synerise/ds-date-range-picker/dist/RangeFilter/Shared/SelectionHint/SelectionHint';export const MAX_RANGES = 4;const texts = {};const Weekly: React.FC<DailyProps> = ({ valueSelectionMode = ['Hour'] }) => {  const defaultDayValue = React.useMemo(    () => ({      start: DEFAULT_RANGE_START,      stop: DEFAULT_RANGE_END,      restricted: false,      display: false,      inverted: false,      mode: valueSelectionMode[0],    }),    [valueSelectionMode]  );  const [schedule, setSchedule] = React.useState<WeeklySchedule>({});  const [filteredSchedule, setFilteredSchedule] = React.useState<string[]>(Object.keys(schedule));  const [activeDays, setActiveDays] = React.useState<DayKey[]>([]);  const ref = React.useRef<HTMLDivElement>();  const [controlKeyPressed, shiftKeyPressed] = useShiftAndControlKeys(ref);  const intl = useIntl();  const allKeys = React.useMemo(() => range(7), []);  const removeEmptyEntries = React.useCallback((schedule: WeeklySchedule) => {    const emptyEntries = Object.keys(schedule).filter(key => Object.keys(schedule[key]).length === 0);    const scheduleToUpdate = schedule;    emptyEntries.forEach(emptyEntry => {      delete scheduleToUpdate[emptyEntry];    });    setSchedule(scheduleToUpdate);  }, []);  React.useEffect(() => {    const entriesWithActiveDaysValue = Object.keys(schedule).filter(id =>      activeDays.every(day => !!schedule[id][day] && haveActiveDaysCommonRange(schedule[id], activeDays))    );    removeEmptyEntries(schedule);    setFilteredSchedule(entriesWithActiveDaysValue);  }, [schedule, activeDays, removeEmptyEntries]);  const handleDayTimeChange = React.useCallback(    (value: [Date, Date], dayKey: DayKey | DayKey[], guid: string): void => {      const updatedSchedule = schedule;      if (dayKey instanceof Array) {        dayKey.forEach(day => {          updatedSchedule[guid][day] = {            ...schedule[guid][day],            restricted: true,            start: dayjs(value[0]).format(TIME_FORMAT),            stop: dayjs(value[1]).format(TIME_FORMAT),          };        });      } else {        updatedSchedule[guid][dayKey] = {          ...schedule[guid][dayKey],          restricted: true,          start: dayjs(value[0]).format(TIME_FORMAT),          stop: dayjs(value[1]).format(TIME_FORMAT),        };      }      setSchedule(updatedSchedule);    },    [schedule]  );  const getDayValue = React.useCallback(    (dayKey?: DayKey, guid: string): WeeklySchedule => {      if (typeof dayKey === 'number' && !!schedule[guid][dayKey]) {        return schedule[guid][dayKey];      }      return defaultDayValue;    },    [schedule, defaultDayValue]  );  const handleModeChange = React.useCallback(    (selectedMode: DateLimitMode, dayKeys: DayKey[], guid: string): void => {      const updatedSchedule = schedule;      dayKeys.forEach(day => {        updatedSchedule[guid][day] = {          ...schedule[guid][day],          mode: selectedMode,        };      });      setSchedule(updatedSchedule);    },    [schedule]  );  const handleRangeDelete = React.useCallback(    (guid: string, activeDaysArray): void => {      const updatedSchedule = schedule;      activeDaysArray.forEach(activeDay => {        delete updatedSchedule[guid][activeDay];      });      setSchedule({ ...updatedSchedule });    },    [schedule]  );  const dayFormatter = React.useCallback(    (dayKey: DayKey): React.ReactNode => intl.formatMessage({ id: `DS.DATE-RANGE-PICKER.WEEKDAYS-SHORT-${dayKey}` }),    [intl]  );  const checkDay = (dayKey: DayKey): void => {    setActiveDays([dayKey]);  };  const getDayLabel = (dayKey: DayKey): React.ReactNode => {    return dayFormatter(dayKey);  };  const isDayRestricted = (dayKey: DayKey): boolean => {    return Object.keys(schedule).some((key: string) => !!schedule[key][dayKey]);  };  const removeDaySelection = React.useCallback(    (dayKey: DayKey) => {      const updatedSchedule = schedule;      Object.keys(schedule).forEach(key => {        delete updatedSchedule[key][dayKey];      });      setActiveDays(activeDays.filter(day => day !== dayKey));      setSchedule(updatedSchedule);    },    [schedule, activeDays]  );  const uncheckActiveDay = React.useCallback(    (dayKey: DayKey): void => {      removeDaySelection(dayKey);    },    [removeDaySelection]  );  const handleSelectAll = (): void => {    setActiveDays(allKeys);  };  const handleUnselectAll = (): void => {    setActiveDays([]);  };  const checkActiveDay = (dayKey: DayKey): void => {    if (!isDayRestricted(dayKey)) {      checkDay(dayKey);    }    let updatedActiveDay: DayKey[] = [];    if (controlKeyPressed) {      updatedActiveDay = activeDays.includes(dayKey) ? activeDays : [...activeDays, dayKey];    } else if (activeDays.length > 0 && shiftKeyPressed) {      updatedActiveDay =        activeDays[0] < dayKey ? range(+activeDays[0], +dayKey + 1) : range(+dayKey, +activeDays[0] + 1);    } else {      updatedActiveDay = [dayKey];    }    setActiveDays(updatedActiveDay);  };  const handleToggleDay = React.useCallback(    (dayKey: DayKey, forcedState?: boolean): void => {      if (typeof forcedState !== 'undefined') {        if (controlKeyPressed && forcedState) {          activeDays.includes(dayKey) ? uncheckActiveDay(dayKey) : checkActiveDay(dayKey);          return;        }        forcedState ? checkActiveDay(dayKey) : uncheckActiveDay(dayKey);      } else {        activeDays.includes(dayKey) ? uncheckActiveDay(dayKey) : checkActiveDay(dayKey);      }    },    [controlKeyPressed, activeDays, uncheckActiveDay, checkActiveDay]  );  const renderDay = React.useCallback(    (dayKey: DayKey): JSX.Element => {      const isActive = activeDays.includes(dayKey);      return (        <Day          key={dayKey}          dayKey={dayKey}          data-attr={dayKey}          label={getDayLabel(dayKey)}          restricted={isDayRestricted(dayKey)}          active={isActive}          readOnly={false}          intl={intl}          onToggle={handleToggleDay}          texts={texts}        />      );    },    [activeDays, intl]  );  const handleRangeAdd = React.useCallback(() => {    const updated = {};    const guid = Object.keys(schedule).find(key => activeDays.every(day => schedule[key][day] === undefined));    activeDays.forEach(day => {      updated[day] = defaultDayValue;    });    const restOfScheduleObject = guid ? schedule[guid] : {};    setSchedule({      ...schedule,      [guid || uuid()]: {        ...restOfScheduleObject,        ...updated,      },    });  }, [schedule, activeDays, defaultDayValue]);  console.log('schedule', schedule);  const shouldRenderAddButton =    activeDays.length > 0 && filteredSchedule.length < MAX_RANGES && canAddAnotherRange(schedule, activeDays);  return (    <S.Wrapper ref={ref as RefObject<HTMLDivElement>}>      <Grid        reverseGroup={0}        onUnselectAll={handleUnselectAll}        onSelectAll={handleSelectAll}        showUnselectAll={Boolean(activeDays.length)}        showSelectAll        renderDay={renderDay}        keys={allKeys}        days={{}}        intl={intl}        numberOfDays={7}        texts={texts}        title={          <SelectionCount            selectedDayCount={activeDays.length}            label={intl.formatMessage({ id: 'DS.DATE-RANGE-PICKER.SELECTED' })}          />        }      />      {filteredSchedule.map((guid, index) => (        <RangeFormContainer          key={`schedule-range-${guid}`}          onDayTimeChange={(value, dayKey): void => {            handleDayTimeChange(value, dayKey, guid);          }}          texts={{}}          onMultipleDayTimeChange={(dates: [Date, Date]): void => handleDayTimeChange(dates, activeDays, guid)}          dayKeys={activeDays}          getDayLabel={getDayLabel}          activeDays={activeDays}          getDayValue={(dayKey: DayKey): WeeklySchedule => getDayValue(dayKey, guid)}          onRangeDelete={(): void => handleRangeDelete(guid, activeDays)}          onModeChange={(mode): void => handleModeChange(mode, activeDays, guid)}          valueSelectionModes={valueSelectionMode}          hideHeader={index !== 0}          renderSuffix={() => null}          timePickerProps={{            containerStyle: { width: '268px', maxWidth: 'none' },            units: ['hour', 'minute'],            timeFormat: 'HH:mm',          }}        />      ))}      {shouldRenderAddButton && <AddButton label="Add range" onClick={handleRangeAdd} />}      <SelectionHint message={'Hello'} />    </S.Wrapper>  );};export default Weekly;